package simpledb;
import java.util.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join implements DbIterator {

	private JoinPredicate predicate;
	private DbIterator child1;
	private DbIterator child2;
	private Tuple outerTuple;
	
  /**
   * Constructor.  Accepts two children to join and the predicate
   * to join them on
   * @param p The predicate to use to join the children
   * @param child1 Iterator for the left(outer) relation to join
   * @param child2 Iterator for the right(inner) relation to join
   */
  public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
    // some code goes here
  	predicate = p;
  	this.child1 = child1;
  	this.child2 = child2;
  }

  public TupleDesc getTupleDesc() {
    // some code goes here
    return TupleDesc.combine(child1.getTupleDesc(), child2.getTupleDesc());
  }

  public void open() throws DbException, NoSuchElementException, TransactionAbortedException {
    // some code goes here
  	child1.open();
  	child2.open();
  }

  public void close() {
    // some code goes here
  	child1.close();
  	child2.close();
  }

  public void rewind() throws DbException, TransactionAbortedException {
    // some code goes here
  	child1.rewind();
  	child2.rewind();
  }

  /**
   * Returns the next tuple generated by the join.
   * Logically, this is the next tuple in r1 cross r2 that satisfies the join
   * predicate.  There are many possible implementations; the simplest is a
   * nested loops join.
   * <p>
   * Note that the tuples returned from this particular implpementation of
   * Join are simply the concatenation of joining tuples from the left and
   * right relation. Therefore, there will be two copies of the join attribute
   * in the results.  (Removing such duplicate columns can be done with an
   * additional projection operator if needed.)
   * <p>
   * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
   * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
   *
   * @return The next matching tuple.
   * @see JoinPredicate#filter
   */
  public Tuple getNext() throws NoSuchElementException, TransactionAbortedException {
    // some code goes here
		if (outerTuple == null)
			outerTuple = child1.getNext();
		
  	Tuple innerTuple = null;
  	
  	// loop terminates when child1.getNext() throws NoSuchElementException
  	while (true) {
  		try {
  			innerTuple = child2.getNext();
  			if (predicate.filter(outerTuple, innerTuple)) {
  				return joinTuple(outerTuple, innerTuple);
  			}
  		} catch (NoSuchElementException noee) {
  			outerTuple = child1.getNext();
  			try {
  				child2.rewind();
  			} catch (DbException de) {
  				de.printStackTrace();
  				throw new NoSuchElementException("Unable to rewind child2");
  			}
  		}
  	}
  }
  
  private Tuple joinTuple(Tuple tuple1, Tuple tuple2) {
  	Tuple joinedTuple = new Tuple(getTupleDesc());
  	for (int i = 0; i < tuple1.getTupleDesc().numFields(); i++) {
  		joinedTuple.setField(i, tuple1.getField(i));
  	}
  	int tuple1Size = tuple1.getTupleDesc().numFields();
  	for (int i = 0; i < tuple2.getTupleDesc().numFields(); i++) {
  		joinedTuple.setField(i + tuple1Size, tuple2.getField(i));
  	}
  	return joinedTuple;
  }
}
